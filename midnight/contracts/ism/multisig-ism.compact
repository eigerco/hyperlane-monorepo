pragma language_version >= 0.13.0;

/**
 * Hyperlane MultisigISM (Interchain Security Module) for Midnight
 *
 * Validates inbound messages using M-of-N validator signatures.
 * Based on Cardano implementation (ismMultiSig.hl).
 *
 * Signature Verification Flow:
 * 1. Compute checkpoint digest from message + merkle root
 * 2. Verify M signatures from N validators match the digest
 * 3. If threshold met, message is considered valid
 */

export {verify, getThreshold, getValidatorCount, ISMMetadata, Checkpoint}

import CompactStandardLibrary;

/**
 * ISM Configuration (set at deployment via constructor)
 */
ledger threshold: Uint<8>;           // M - minimum signatures required
ledger validatorCount: Uint<8>;      // N - total validators

/**
 * Validator public keys stored in a map
 * Index (0 to N-1) => PublicKey (32 bytes)
 */
export ledger validators: Map<Uint<8>, Bytes<32>>;

/**
 * ISM Metadata structure for signature verification
 * Contains merkle root and validator signatures
 */
struct ISMMetadata {
  merkleRoot: Bytes<32>;             // Checkpoint merkle root
  signatures: Bytes<2048>;           // Up to 32 signatures (64 bytes each)
  signatureCount: Uint<8>;           // Number of signatures provided
}

/**
 * Checkpoint structure for signature verification
 */
struct Checkpoint {
  origin: Uint<32>;                  // Origin domain ID
  originMailbox: Bytes<32>;          // Mailbox address on origin
  merkleRoot: Bytes<32>;             // Merkle tree root
  nonce: Uint<32>;                   // Message nonce (index)
  messageId: Bytes<32>;              // Message ID (hash)
}

/**
 * Witnesses for off-chain computation
 */

// Compute checkpoint digest for signature verification
// digest = hash(hash(origin + originMailbox + "HYPERLANE") + root + nonce + messageId)
witness computeCheckpointDigest(checkpoint: Checkpoint): Bytes<32>;

// Count valid signatures (off-chain verification)
// Returns number of valid signatures from registered validators
witness countValidSignatures(
  digest: Bytes<32>,
  signatures: Bytes<2048>,
  signatureCount: Uint<8>
): Uint<8>;

/**
 * Constructor - Initialize ISM with validator set
 *
 * @param _threshold - Minimum signatures required (M)
 * @param _validatorCount - Total validators (N)
 * @param v0 to v7 - Validator public keys (32 bytes each, pass zero bytes for unused)
 */
constructor(
  _threshold: Uint<8>,
  _validatorCount: Uint<8>,
  v0: Bytes<32>,
  v1: Bytes<32>,
  v2: Bytes<32>,
  v3: Bytes<32>,
  v4: Bytes<32>,
  v5: Bytes<32>,
  v6: Bytes<32>,
  v7: Bytes<32>
) {
  threshold = disclose(_threshold);
  validatorCount = disclose(_validatorCount);

  // Store validator keys (up to 8 validators for simplicity)
  validators.insert(0, disclose(v0));
  validators.insert(1, disclose(v1));
  validators.insert(2, disclose(v2));
  validators.insert(3, disclose(v3));
  validators.insert(4, disclose(v4));
  validators.insert(5, disclose(v5));
  validators.insert(6, disclose(v6));
  validators.insert(7, disclose(v7));
}

/**
 * Verify message using ISM
 *
 * @param origin - Origin domain ID
 * @param originMailbox - Mailbox address on origin chain
 * @param nonce - Message nonce
 * @param messageId - Message ID (hash)
 * @param metadata - ISM metadata with merkle root and signatures
 *
 * Fails if signature threshold not met.
 */
export circuit verify(
  origin: Uint<32>,
  originMailbox: Bytes<32>,
  nonce: Uint<32>,
  messageId: Bytes<32>,
  metadata: ISMMetadata
): [] {
  // Construct checkpoint
  const checkpoint = Checkpoint {
    origin: disclose(origin),
    originMailbox: disclose(originMailbox),
    merkleRoot: disclose(metadata.merkleRoot),
    nonce: disclose(nonce),
    messageId: disclose(messageId)
  };

  // Compute checkpoint digest
  const digest = computeCheckpointDigest(checkpoint);

  // Count valid signatures (off-chain with witness)
  const validCount = countValidSignatures(
    digest,
    disclose(metadata.signatures),
    disclose(metadata.signatureCount)
  );

  // Check threshold met
  assert(disclose(validCount) >= threshold, "Signature threshold not met");
}

/**
 * Get current threshold
 */
export circuit getThreshold(): Uint<8> {
  return threshold;
}

/**
 * Get validator count
 */
export circuit getValidatorCount(): Uint<8> {
  return validatorCount;
}
