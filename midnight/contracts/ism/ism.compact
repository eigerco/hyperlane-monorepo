pragma language_version >= 0.13.0;

/**
 * Hyperlane ISM (Interchain Security Module) for Midnight
 *
 * Relayer attestation-based verification:
 * 1. Relayer collects ECDSA validator signatures off-chain
 * 2. Relayer creates commitment = hash(messageId || validatorSignatures)
 * 3. Relayer signs commitment with secp256k1 key
 * 4. ISM verifies secp256k1 signature via witness (off-chain until Midnight adds native support)
 * 5. ISM stores verification receipt for Mailbox to check
 */

export {verify, isVerified, addRelayer, removeRelayer, ISMMetadata}

import CompactStandardLibrary;

// =============================================================================
// Ledger State
// =============================================================================

/**
 * Authorized relayers that can submit attestations
 * secp256k1 public key (33 bytes compressed) => 1 (authorized)
 */
ledger authorizedRelayers: Map<Bytes<33>, Uint<8>>;

/**
 * Verification receipts for processed messages
 * messageId (32 bytes) => 1 (verified)
 */
ledger verificationReceipts: Map<Bytes<32>, Uint<8>>;

// =============================================================================
// Types
// =============================================================================

/**
 * ISM Metadata for relayer attestation
 */
struct ISMMetadata {
  commitment: Bytes<32>;           // hash(messageId || validatorSignatures)
  relayerPubKey: Bytes<33>;        // secp256k1 compressed public key (33 bytes)
  relayerSignature: Bytes<64>;     // secp256k1 signature (64 bytes, r || s)
}

// =============================================================================
// Witnesses
// =============================================================================

/**
 * Verify secp256k1 ECDSA signature
 * Runs off-chain until Midnight adds native secp256k1 verification
 * Returns 1 if valid, 0 if invalid
 */
witness verifySecp256k1Signature(
  pubKey: Bytes<33>,
  message: Bytes<32>,
  signature: Bytes<64>
): Uint<8>;

// =============================================================================
// Core Circuits
// =============================================================================

/**
 * Verify message using relayer attestation
 *
 * @param messageId - Message ID (keccak256 hash from origin chain)
 * @param metadata - Relayer attestation with commitment and secp256k1 signature
 */
export circuit verify(
  messageId: Bytes<32>,
  metadata: ISMMetadata
): [] {
  // 1. Check relayer is authorized
  assert(
    authorizedRelayers.member(disclose(metadata.relayerPubKey)),
    "Unauthorized relayer"
  );

  // 2. Verify secp256k1 signature over commitment
  const isValid = verifySecp256k1Signature(
    disclose(metadata.relayerPubKey),
    disclose(metadata.commitment),
    disclose(metadata.relayerSignature)
  );
  assert(disclose(isValid) == 1, "Invalid relayer signature");

  // 3. Store verification receipt
  verificationReceipts.insert(disclose(messageId), 1);
}

/**
 * Check if a message has been verified
 *
 * @param messageId - Message ID to check
 * @returns 1 if verified, fails if not
 */
export circuit isVerified(messageId: Bytes<32>): Uint<8> {
  assert(
    verificationReceipts.member(disclose(messageId)),
    "Message not verified"
  );
  return 1;
}

// =============================================================================
// Admin Circuits
// =============================================================================

/**
 * Add an authorized relayer
 *
 * @param relayerPubKey - secp256k1 compressed public key of relayer to authorize
 */
export circuit addRelayer(relayerPubKey: Bytes<33>): [] {
  authorizedRelayers.insert(disclose(relayerPubKey), 1);
}

/**
 * Remove an authorized relayer
 *
 * @param relayerPubKey - secp256k1 compressed public key of relayer to remove
 */
export circuit removeRelayer(relayerPubKey: Bytes<33>): [] {
  authorizedRelayers.remove(disclose(relayerPubKey));
}
