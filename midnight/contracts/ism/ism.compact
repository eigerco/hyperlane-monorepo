pragma language_version >= 0.13.0;

/**
 * Hyperlane ISM (Interchain Security Module) for Midnight
 *
 * Relayer attestation-based verification:
 * 1. Relayer verifies ECDSA validator signatures off-chain
 * 2. Relayer creates commitment = hash(messageId || validatorSignatures)
 * 3. Relayer signs commitment with BIP-340 key
 * 4. ISM verifies BIP-340 signature on-chain via witness
 * 5. ISM stores verification receipt for Mailbox to check
 */

export {verify, isVerified, addRelayer, removeRelayer, ISMMetadata}

import CompactStandardLibrary;

// =============================================================================
// Ledger State
// =============================================================================

/**
 * Authorized relayers that can submit attestations
 * BIP-340 public key (32 bytes) => 1 (authorized)
 */
ledger authorizedRelayers: Map<Bytes<32>, Uint<8>>;

/**
 * Verification receipts for processed messages
 * messageId (32 bytes) => 1 (verified)
 */
ledger verificationReceipts: Map<Bytes<32>, Uint<8>>;

// =============================================================================
// Types
// =============================================================================

/**
 * ISM Metadata for relayer attestation
 */
struct ISMMetadata {
  commitment: Bytes<32>;           // hash(messageId || validatorSignatures)
  relayerPubKey: Bytes<32>;        // BIP-340 public key (32 bytes)
  relayerSignature: Bytes<64>;     // BIP-340 signature (64 bytes)
}

// =============================================================================
// Witnesses
// =============================================================================

/**
 * Verify BIP-340 signature using Midnight's native verification
 * Returns 1 if valid, 0 if invalid
 */
witness verifyBIP340Signature(
  pubKey: Bytes<32>,
  message: Bytes<32>,
  signature: Bytes<64>
): Uint<8>;

// =============================================================================
// Core Circuits
// =============================================================================

/**
 * Verify message using relayer attestation
 *
 * @param messageId - Message ID (keccak256 hash from origin chain)
 * @param metadata - Relayer attestation with commitment and BIP-340 signature
 */
export circuit verify(
  messageId: Bytes<32>,
  metadata: ISMMetadata
): [] {
  // 1. Check relayer is authorized
  assert(
    authorizedRelayers.member(disclose(metadata.relayerPubKey)),
    "Unauthorized relayer"
  );

  // 2. Verify BIP-340 signature over commitment
  const isValid = verifyBIP340Signature(
    disclose(metadata.relayerPubKey),
    disclose(metadata.commitment),
    disclose(metadata.relayerSignature)
  );
  assert(disclose(isValid) == 1, "Invalid relayer signature");

  // 3. Store verification receipt
  verificationReceipts.insert(disclose(messageId), 1);
}

/**
 * Check if a message has been verified
 *
 * @param messageId - Message ID to check
 * @returns 1 if verified, fails if not
 */
export circuit isVerified(messageId: Bytes<32>): Uint<8> {
  assert(
    verificationReceipts.member(disclose(messageId)),
    "Message not verified"
  );
  return 1;
}

// =============================================================================
// Admin Circuits
// =============================================================================

/**
 * Add an authorized relayer
 *
 * @param relayerPubKey - BIP-340 public key of relayer to authorize
 */
export circuit addRelayer(relayerPubKey: Bytes<32>): [] {
  authorizedRelayers.insert(disclose(relayerPubKey), 1);
}

/**
 * Remove an authorized relayer
 *
 * @param relayerPubKey - BIP-340 public key of relayer to remove
 */
export circuit removeRelayer(relayerPubKey: Bytes<32>): [] {
  authorizedRelayers.remove(disclose(relayerPubKey));
}
