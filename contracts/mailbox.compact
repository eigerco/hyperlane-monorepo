/**
 * Hyperlane Mailbox Contract for Midnight
 *
 * The Mailbox is the core contract for Hyperlane cross-chain messaging.
 * It provides two main functions:
 * 1. dispatch() - Send messages to other chains
 * 2. deliver() - Receive and validate messages from other chains
 *
 * This implementation follows the Hyperlane protocol specification while
 * adapting to Midnight's UTXO model and privacy features.
 */

export {initialize, dispatch, deliver, delivered, latestDispatchedId, Message}

import CompactStandardLibrary;

/**
 * Hyperlane Message Structure (inlined from message.compact)
 */
struct Message {
  version: Uint<8>;
  nonce: Uint<32>;
  origin: Uint<32>;
  sender: Bytes<32>;
  destination: Uint<32>;
  recipient: Bytes<32>;
  bodyLength: Uint<16>;
  body: Bytes<1024>;
}

/**
 * Witnesses for message handling
 */

// Provides message ID (hash) computed off-chain
witness getMessageId(message: Message): Bytes<32>;

// Check if message is delivered (returns 1 if delivered, 0 if not)
witness checkDelivered(messageId: Bytes<32>): Uint<1>;

// Validate message with ISM - must succeed or fail (no return value)
// Off-chain code verifies signatures and provides proof
witness validateWithISM(message: Message, metadata: Bytes<1024>): [];

// Provides zero bytes (all zeros)
witness getZeroBytes(): Bytes<32>;

// Get sender address from transaction context (provided by off-chain code)
witness getSender(): Bytes<32>;

// Get latest message ID from ledger map
witness getLatestMessageId(): Bytes<32>;

// Get current nonce value from Counter
witness getCurrentNonce(): Uint<32>;

/**
 * Helper circuits
 */

circuit computeMessageId(message: Message): Bytes<32> {
  return disclose(getMessageId(message));
}

circuit validateMessage(message: Message): [] {
  assert(disclose(message.version) <= 3, "Unsupported message version");
  assert(disclose(message.bodyLength) <= 1024, "Body length exceeds maximum");
}

/**
 * Ledger State
 */

// Message nonce counter (increments with each dispatch)
ledger nonce: Counter;

// Tracks delivered messages to prevent replay attacks
// messageId => delivered (true/false)
ledger deliveredMessages: Map<Bytes<32>, Uint<8>>;

// Latest dispatched message ID (stored in map with key=0 for off-chain tracking)
ledger latestDispatchedMessageId: Map<Uint<8>, Bytes<32>>;

/**
 * Initialization
 *
 * Sets up the contract with default values.
 * Must be called once during deployment.
 */
circuit initialize(): [] {
  nonce.resetToDefault();

  // Initialize latest message ID to zeros (stored at key 0)
  latestDispatchedMessageId.insert(0, disclose(getZeroBytes()));
}

/**
 * Dispatch - Send a message to another chain
 *
 * Creates a Hyperlane message and stores it for off-chain relay.
 * Returns the message ID for tracking.
 *
 * @param localDomainId - This chain's Hyperlane domain ID
 * @param destination - Destination chain domain ID
 * @param recipient - Recipient address on destination (32 bytes)
 * @param bodyLength - Actual length of message body
 * @param body - Message payload (max 1024 bytes, padded if needed)
 * @returns messageId - Unique identifier for this message
 */
circuit dispatch(
  localDomainId: Uint<32>,
  destination: Uint<32>,
  recipient: Bytes<32>,
  bodyLength: Uint<16>,
  body: Bytes<1024>
): Bytes<32> {
  // Get current nonce (from witness)
  const currentNonce = getCurrentNonce();

  // TODO: Get sender from transaction context
  // For M1: Sender will be provided as a witness
  // In production: Extract from tx context
  const sender = getSender();

  // Construct message
  const message = Message {
    version: 3,
    nonce: currentNonce,
    origin: disclose(localDomainId),
    sender: sender,
    destination: disclose(destination),
    recipient: disclose(recipient),
    bodyLength: disclose(bodyLength),
    body: disclose(body)
  };

  // Validate message structure
  validateMessage(message);

  // Compute message ID
  const messageId = computeMessageId(message);

  // Store latest message ID (for off-chain indexing, stored at key 0)
  latestDispatchedMessageId.insert(0, messageId);

  // Increment nonce for next message
  nonce.increment(1);

  // Note: In Ethereum, we'd emit Dispatch event here
  // In Midnight, off-chain indexer will detect ledger state change
  // and extract the message from latestDispatchedMessageId

  return messageId;
}

/**
 * Deliver - Receive and validate a message from another chain
 *
 * Validates the message using the ISM (Interchain Security Module)
 * and marks it as delivered to prevent replay attacks.
 *
 * @param localDomainId - This chain's Hyperlane domain ID
 * @param message - The Hyperlane message to deliver
 * @param metadata - ISM-specific metadata (signatures, proofs, etc.)
 *
 * For M1: metadata contains validator signatures
 * Format TBD based on available cryptographic primitives
 */
circuit deliver(
  localDomainId: Uint<32>,
  message: Message,
  metadata: Bytes<1024>
): [] {
  // Validate message structure
  validateMessage(message);

  // Check destination matches this chain
  assert(disclose(message.destination) == disclose(localDomainId),
    "Message destination does not match this chain");

  // Compute message ID
  const messageId = computeMessageId(message);

  // Check if already delivered (prevent replay)
  assert(checkDelivered(messageId) == 0, "Message already delivered");

  // Validate using ISM
  // For M1: Simplified validation
  // TODO: Implement proper ISM validation with signatures
  validateWithISM(message, metadata);

  // Mark as delivered
  deliveredMessages.insert(messageId, 1);

  // Note: In Ethereum, we'd emit Process event here
  // In Midnight, off-chain code watches deliveredMessages map changes

  // TODO: Execute recipient contract if needed (M2+)
  // For M1: Just accept and store the message
}

/**
 * Check if a message has been delivered
 *
 * @param messageId - The message ID to check
 * @returns true if delivered, false otherwise
 */
circuit delivered(messageId: Bytes<32>): [] {
  // This circuit succeeds if message is delivered, fails otherwise
  assert(checkDelivered(disclose(messageId)) == 1, "Message not delivered");
}

/**
 * Get the latest dispatched message ID
 *
 * Used by off-chain indexer to discover new messages.
 *
 * @returns Latest message ID
 */
circuit latestDispatchedId(): Bytes<32> {
  return disclose(getLatestMessageId());
}
